<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Clinseq Team">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Clinseq - Autoseq 2.0</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Clinseq";
    var mkdocs_page_input_path = "lld/clinseq.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Autoseq 2.0</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">Autoseq</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../autoseq/">Quick Start</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../pipeline/">Work Flow</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Autoseq 2.0</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>Clinseq</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="clinseqpipeline">ClinseqPipeline</h1>
<p>A pipeline for processing clinseq cancer genomics.</p>
<ul>
<li>sampledata: A dictionary specifying the clinseq barcodes of samples of different types.</li>
<li>refdata: A dictionary specifying the reference data used for configuring the pipeline jobs.</li>
<li>outdir: Output folder location string.</li>
<li>libdir: String specifying location of the library fastq files.</li>
<li>maxcores: Maximum number of cores to use concurrently in this analysis.</li>
<li>scratch: String indicating folder in which jobs should output all temporary files.</li>
<li>kwargs: Additional key-word arguments.</li>
</ul>
<p>ClinseqPipeline is backbone of autoseq, most of the funtions and file manipulations are written with in this class. </p>
<pre><code class="py">class ClinseqPipeline(PypedreamPipeline):
    def __init__(self, sampledata, refdata, job_params, outdir, libdir, maxcores=1,
                 scratch=&quot;/scratch/tmp/tmp&quot;, analysis_id=None, **kwargs):
        PypedreamPipeline.__init__(self, normpath(outdir), **kwargs)
        self.sampledata = sampledata
        self.refdata = refdata
        # FIXME: Introduced a simple dictionary for configuring various pipeline job parameters.
        # However, this solution is still not elegant:
        self.job_params = job_params
        self.maxcores = maxcores
        self.libdir = libdir
        self.qc_files = []
        self.scratch = scratch
        self.analysis_id = analysis_id

        # Set up default job parameters:
        self.default_job_params = {
            &quot;cov-high-thresh-fraction&quot;: 0.95,
            &quot;cov-high-thresh-fold-cov&quot;: 100,
            &quot;cov-low-thresh-fraction&quot;: 0.95,
            &quot;cov-low-thresh-fold-cov&quot;: 50,
            &quot;vardict-min-alt-frac&quot;: 0.02,
            &quot;vardict-min-num-reads&quot;: None,
            &quot;vep-additional-options&quot;: &quot;&quot;
        }

        # Dictionary linking unique captures to corresponding generic single panel
        # analysis results (SinglePanelResults objects as values):
        self.capture_to_results = collections.defaultdict(SinglePanelResults)

        # Dictionary linking unique normal library capture items to their corresponding
        # germline VCF filenames:
        self.normal_capture_to_vcf = {}

        # Dictionary linking (normal capture, cancer capture) pairings to corresponding
        # cancer library capture analysis results (CancerPanelResults objects as values):
        self.normal_cancer_pair_to_results = collections.defaultdict(CancerVsNormalPanelResults)
</code></pre>

<h3 id="get_job_param">get_job_param</h3>
<p>Retrieve the parameter of the specified name from the job parameters, or
return a default value if it is not found.</p>
<ul>
<li>param param_name: String defining the parameter to retrieve </li>
<li>return: The parameter value to use.</li>
</ul>
<pre><code class="py">def get_job_param(self, param_name):
    if param_name in self.job_params.keys():
        return self.job_params[param_name]
    else:
        return self.default_job_params[param_name]
</code></pre>

<h3 id="set_germline_vcf">set_germline_vcf</h3>
<p>Registers the specified vcf filename for the specified normal capture item,
for this analysis.</p>
<ul>
<li>normal_capture: Normal panel capture identifier.</li>
<li>vcfs: Tuple specifying (germline_variants_vcf, vepped_germline_variants_vcf)</li>
</ul>
<pre><code class="py">def set_germline_vcf(self, normal_capture, vcfs):
    self.normal_capture_to_vcf[normal_capture] = vcfs
</code></pre>

<h3 id="get_germline_vcf">get_germline_vcf</h3>
<p>Obtain the germline VCF (original, un-vepped) for the given normal sample capture item.</p>
<ul>
<li>param normal_capture: Named tuple indicating a unique library capture.</li>
<li>return: Original (un-vepped) germline VCF if available, otherwise None.</li>
</ul>
<pre><code class="py">def get_germline_vcf(self, normal_capture):
    if normal_capture in self.normal_capture_to_vcf:
        return self.normal_capture_to_vcf[normal_capture][0]
    else:
        return None
</code></pre>

<h3 id="get_vepped_germline_vcf">get_vepped_germline_vcf</h3>
<p>Obtain the VEPped germline VCFs (original) for the given normal sample capture item.</p>
<ul>
<li>normal_capture: Named tuple indicating a unique library capture. </li>
<li>return: VEPped germline VCF if available, otherwise None.</li>
</ul>
<pre><code class="py">def get_vepped_germline_vcf(self, normal_capture):
    if normal_capture in self.normal_capture_to_vcf:
        return self.normal_capture_to_vcf[normal_capture][1]
    else:
        return None
</code></pre>

<h3 id="set_capture_bam">set_capture_bam</h3>
<p>Set the bam file corresponding to the specified unique_capture in this analysis.</p>
<ul>
<li>unique_capture: A UniqueCapture item. </li>
<li>bam: The bam filename.</li>
</ul>
<pre><code class="py">def set_capture_bam(self, unique_capture, bam):

    self.capture_to_results[unique_capture].merged_bamfile = bam
</code></pre>

<h3 id="set_capture_sveffect">set_capture_sveffect</h3>
<p>Record the structural variants effect prediction.</p>
<ul>
<li>unique_capture: Named tuple indicating unique library capture.</li>
<li>effects_json: String indicating JSON file of predicted effects</li>
</ul>
<pre><code class="py">def set_capture_sveffect(self, unique_capture, effects_json):
    self.capture_to_results[unique_capture].sv_effects = effects_json
</code></pre>

<h3 id="set_capture_svs">set_capture_svs</h3>
<p>Record the structural variants results for the given library capture and event type.</p>
<ul>
<li>unique_capture: Named tuple indicating unique library capture.</li>
<li>event_type: String indicating structural variant event type</li>
<li>svs_tup: Tuple containing (bam_filename, gtf_filename)</li>
</ul>
<pre><code class="py">def set_capture_svs(self, unique_capture, event_type, svs_tup):
    self.capture_to_results[unique_capture].svs[event_type] = svs_tup
</code></pre>

<h3 id="set_capture_cnr">set_capture_cnr</h3>
<p>Record the CNR copy number information (CNV kit output) for the given library capture.</p>
<ul>
<li>unique_capture: Named tuple indicating unique library capture.</li>
<li>cnr: CNR output filename.</li>
</ul>
<pre><code class="py">def set_capture_cnr(self, unique_capture, cnr):

    self.capture_to_results[unique_capture].cnr = cnr 
</code></pre>

<h3 id="set_capture_cns">set_capture_cns</h3>
<p>Record the CNS copy number information (CNV kit output) for the given library capture.</p>
<ul>
<li>unique_capture: Named tuple indicating unique library capture.</li>
<li>cnr: CNS output filename.</li>
</ul>
<pre><code class="py">def set_capture_cns(self, unique_capture, cns):
    self.capture_to_results[unique_capture].cns = cns
</code></pre>

<h3 id="set_capture_seg">set_capture_seg</h3>
<p>Record the seg file (converted CNV kit output) for the given library capture.</p>
<ul>
<li>unique_capture: Named tuple indicating unique library capture.</li>
<li>cnr: CNS output filename.</li>
</ul>
<pre><code class="py">def set_capture_seg(self, unique_capture, seg):
    self.capture_to_results[unique_capture].seg = seg
</code></pre>

<h3 id="get_capture_bam">get_capture_bam</h3>
<p>Retrieve the bam file corresponding to the specified unique_capture in this analysis.</p>
<ul>
<li>unique_capture: Named tuple indicating unique library capture.</li>
<li>return: The corresponding bam filename, or None if it has not been configured.</li>
</ul>
<pre><code class="py">def get_capture_bam(self, unique_capture):

    if unique_capture in self.get_mapped_captures_all():
        return self.capture_to_results[unique_capture].merged_bamfile
    else:
        return None
</code></pre>

<h3 id="check_sampledata">check_sampledata</h3>
<p>Check this pipeline for validity of the sample data. In particular, check that
each clinseq barcode has a corresponding fastq file, and if not, then modify
the pipeline's sampledata by removing that clinseq barcode from the analysis.</p>
<pre><code class="py">def check_sampledata(self):
    for sample_type in ['N', 'T', 'CFDNA']:
        clinseq_barcodes_with_data = []
        for clinseq_barcode in self.sampledata[sample_type]:
            if data_available_for_clinseq_barcode(self.libdir, clinseq_barcode):
                clinseq_barcodes_with_data.append(clinseq_barcode)

        self.sampledata[sample_type] = clinseq_barcodes_with_data
</code></pre>

<h3 id="vep_data_is_available">vep_data_is_available</h3>
<p>Indicates whether the VEP folder has been set for this analysis.</p>
<ul>
<li>return: Boolean.</li>
</ul>
<pre><code class="py">def vep_data_is_available(self):

    return self.refdata['vep_dir'] != None
</code></pre>

<h3 id="get_mapped_captures_all">get_mapped_captures_all</h3>
<p>Obtain all unique sample library captures in this pipeline instance (including library -&gt; WGS items).</p>
<ul>
<li>return: List of unique capture named tuples. </li>
</ul>
<pre><code class="py">def get_mapped_captures_all(self):

    return self.capture_to_results.keys()
</code></pre>

<h3 id="get_mapped_captures_no_wgs">get_mapped_captures_no_wgs</h3>
<p>Obtain all unique sample library captures in this pipeline instance (excluding library -&gt; WGS items).</p>
<ul>
<li>return: List of unique capture named tuples.</li>
</ul>
<pre><code class="py">def get_mapped_captures_no_wgs(self):

    return [capture for capture in self.capture_to_results.keys()
            if capture.capture_kit_id != &quot;WG&quot;]
</code></pre>

<h3 id="get_mapped_captures_only_wgs">get_mapped_captures_only_wgs</h3>
<p>Obtain all unique sample library captures in this pipeline instance (only including library -&gt; WGS items).</p>
<ul>
<li>return: List of unique capture named tuples.</li>
</ul>
<pre><code class="py">def get_mapped_captures_only_wgs(self):

    return [capture for capture in self.capture_to_results.keys()
            if capture.capture_kit_id == &quot;WG&quot;]
</code></pre>

<h3 id="get_mapped_captures_normal">get_mapped_captures_normal</h3>
<p>Obtain tuples for all unique normal sample library captures in this pipeline instance - not including "WGS" (no) capture items.</p>
<ul>
<li>return: List of named tuples.</li>
</ul>
<pre><code class="py">def get_mapped_captures_normal(self):

    non_wgs_unique_captures = self.get_mapped_captures_no_wgs()
    return filter(lambda unique_capture: unique_capture.sample_type == &quot;N&quot;,
                  non_wgs_unique_captures)
</code></pre>

<h3 id="get_mapped_captures_cancer">get_mapped_captures_cancer</h3>
<p>Obtain all unique cancer sample library captures items in this pipeline instance - not including "WGS" (no) capture items.</p>
<ul>
<li>return: List of named tuples.</li>
</ul>
<pre><code class="py">def get_mapped_captures_cancer(self):

    non_wgs_unique_captures = self.get_mapped_captures_no_wgs()
    return filter(lambda unique_capture: unique_capture.sample_type != &quot;N&quot;,
                  non_wgs_unique_captures)
</code></pre>

<h3 id="get_prep_kit_name">get_prep_kit_name</h3>
<p>Convert a two-letter library kit code to the corresponding library kit name.</p>
<ul>
<li>param prep_kit_code: Two-letter library prep code. </li>
<li>return: The library prep kit name.</li>
</ul>
<pre><code class="py">def get_prep_kit_name(self, prep_kit_code):

    # FIXME: Move this information to a config JSON file.
    prep_kit_lookup = {&quot;BN&quot;: &quot;BIOO_NEXTFLEX&quot;,
                       &quot;KH&quot;: &quot;KAPA_HYPERPREP&quot;,
                       &quot;TD&quot;: &quot;THRUPLEX_DNASEQ&quot;,
                       &quot;TP&quot;: &quot;THRUPLEX_PLASMASEQ&quot;,
                       &quot;TF&quot;: &quot;THRUPLEX_FD&quot;,
                       &quot;TS&quot;: &quot;TRUSEQ_RNA&quot;,
                       &quot;NN&quot;: &quot;NEBNEXT_RNA&quot;,
                       &quot;VI&quot;: &quot;VILO_RNA&quot;}

    return prep_kit_lookup[prep_kit_code]
</code></pre>

<h3 id="get_capture_name">get_capture_name</h3>
<p>Convert a two-letter capture kit code to the corresponding capture kit name.</p>
<ul>
<li>param capture_kit_code: The two-letter capture kit code.</li>
<li>return: The capture-kit name.</li>
</ul>
<pre><code class="py">def get_capture_name(self, capture_kit_code):

    # FIXME: Move this information to a config JSON file.
    capture_kit_loopkup = {&quot;CS&quot;: &quot;clinseq_v3_targets&quot;,
                           &quot;CZ&quot;: &quot;clinseq_v4&quot;,
                           &quot;EX&quot;: &quot;EXOMEV3&quot;,
                           &quot;EO&quot;: &quot;EXOMEV1&quot;,
                           &quot;RF&quot;: &quot;fusion_v1&quot;,
                           &quot;CC&quot;: &quot;core_design&quot;,
                           &quot;CD&quot;: &quot;discovery_coho&quot;,
                           &quot;CB&quot;: &quot;big_design&quot;,
                           &quot;AL&quot;: &quot;alascca_targets&quot;,
                           &quot;TT&quot;: &quot;test-regions&quot;,
                           &quot;CP&quot;: &quot;progression&quot;,
                           &quot;CM&quot;: &quot;monitor&quot;
                           }

    if capture_kit_code == 'WG':
        return 'lowpass_wgs'

    else:
        return capture_kit_loopkup[capture_kit_code]
</code></pre>

<h3 id="get_all_clinseq_barcodes">get_all_clinseq_barcodes</h3>
<ul>
<li>return: All clinseq barcodes included in this clinseq analysis pipeline's panel data.</li>
</ul>
<pre><code class="py">def get_all_clinseq_barcodes(self):

    all_clinseq_barcodes = \
        self.sampledata['T'] + \
        self.sampledata['N'] + \
        self.sampledata['CFDNA']
    return filter(lambda bc: bc != None, all_clinseq_barcodes)
</code></pre>

<h3 id="get_unique_capture_to_clinseq_barcodes">get_unique_capture_to_clinseq_barcodes</h3>
<p>Retrieves all clinseq barcodes for this clinseq analysis, and organises them according
to unique library captures.</p>
<ul>
<li>return: A dictionary with tuples indicating unique library captures as keys, and barcode lists as values.</li>
</ul>
<pre><code class="py">def get_unique_capture_to_clinseq_barcodes(self):

    capture_to_barcodes = collections.defaultdict(list)
    for clinseq_barcode in self.get_all_clinseq_barcodes():
        unique_capture = extract_unique_capture(clinseq_barcode)
        capture_to_barcodes[unique_capture].append(clinseq_barcode)

    return capture_to_barcodes
</code></pre>

<h3 id="merge_and_rm_dup">merge_and_rm_dup</h3>
<p>Configures Picard merging and duplicate marking, for the specified group input bams,
which should all correspond to the specified sample library capture.</p>
<p>Registers the final output bam file for this library capture in this analysis.</p>
<ul>
<li>param unique_capture: A unique library capture specification</li>
<li>param input_bams: The bam filenames for which to do merging and duplicate marking</li>
</ul>
<pre><code class="py">def merge_and_rm_dup(self, unique_capture, input_bams):

    # Strings indicating the sample and capture, for use in output file names below:
    capture_str = compose_lib_capture_str(unique_capture)
    #sample_str = &quot;{}-{}&quot;.format(unique_capture.sample_type, unique_capture.sample_id)
    #capture_str = &quot;{}-{}-{}&quot;.format(sample_str, unique_capture.library_kit_id, unique_capture.capture_kit_id)

    # Configure merging:
    merged_bam_filename = \
        &quot;{}/bams/{}/{}.bam&quot;.format(self.outdir, unique_capture.capture_kit_id, capture_str)
    merge_bams = PicardMergeSamFiles(input_bams, merged_bam_filename)
    merge_bams.is_intermediate = True
    merge_bams.jobname = &quot;picard-mergebams-{}&quot;.format(capture_str)
    self.add(merge_bams)

    # Configure duplicate marking:
    mark_dups_bam_filename = \
        &quot;{}/bams/{}/{}-nodups.bam&quot;.format(self.outdir, unique_capture.capture_kit_id, capture_str)
    mark_dups_metrics_filename = \
        &quot;{}/qc/picard/{}/{}-markdups-metrics.txt&quot;.format(
            self.outdir, unique_capture.capture_kit_id, capture_str)
    markdups = PicardMarkDuplicates(
        merge_bams.output_bam, mark_dups_bam_filename, mark_dups_metrics_filename)
    markdups.is_intermediate = False
    self.add(markdups)

    self.set_capture_bam(unique_capture, markdups.output_bam)

    self.qc_files.append(markdups.output_metrics)
</code></pre>

<h3 id="configure_fastq_qcs">configure_fastq_qcs</h3>
<p>Configure QC on all fastq files that exist for this pipeline instance.</p>
<ul>
<li>return: List of qc output filenames.</li>
</ul>
<pre><code class="py">def configure_fastq_qcs(self):

    for clinseq_barcode in self.get_all_clinseq_barcodes():
        curr_fqs = reduce(lambda l1, l2: l1 + l2,
                          find_fastqs(clinseq_barcode, self.libdir))
        for fq in curr_fqs:
            fastqc = FastQC()
            fastqc.input = fq
            fastqc.outdir = &quot;{}/qc/fastqc/&quot;.format(self.outdir)
            fastqc.output = &quot;{}/qc/fastqc/{}_fastqc.zip&quot;.format(
                self.outdir, clinseq_barcode)
            fastqc.jobname = &quot;fastqc-{}&quot;.format(clinseq_barcode)
            self.qc_files.append(fastqc.output)
            self.add(fastqc)
</code></pre>

<h3 id="configure_align_and_merge">configure_align_and_merge</h3>
<p>Configure the aligning of the fastq files for all clinseq barcodes in this pipeline,
and configure merging of the resulting bam files organised according to unique
sample library captures (including "WGS" captures - i.e. no capture).</p>
<pre><code class="py">def configure_align_and_merge(self):

    capture_to_barcodes = self.get_unique_capture_to_clinseq_barcodes()
    for unique_capture in capture_to_barcodes.keys():
        curr_bamfiles = []
        capture_kit = unique_capture.capture_kit_id
        for clinseq_barcode in capture_to_barcodes[unique_capture]:
            curr_bamfiles.append(
                align_library(self,
                              fq1_files=find_fastqs(clinseq_barcode, self.libdir)[0],
                              fq2_files=find_fastqs(clinseq_barcode, self.libdir)[1],
                              clinseq_barcode=clinseq_barcode,
                              ref=self.refdata['bwaIndex'],
                              outdir= &quot;{}/bams/{}&quot;.format(self.outdir, capture_kit),
                              maxcores=self.maxcores,
                              remove_duplicates=True))

        self.merge_and_rm_dup(unique_capture, curr_bamfiles)

</code></pre>

<h3 id="call_germline_variants">call_germline_variants</h3>
<p>Configure calling of germline variants for a normal sample library capture,
and configure VEP if specified in the analysis.</p>
<ul>
<li>param normal_capture: The normal sample library capture identifier.</li>
<li>param bam: Bam filename input to variant calling.</li>
</ul>
<pre><code class="py">def call_germline_variants(self, normal_capture, bam):

    targets = self.get_capture_name(normal_capture.capture_kit_id)
    capture_str = compose_lib_capture_str(normal_capture)

    freebayes = Freebayes()
    freebayes.input_bams = [bam]
    freebayes.somatic_only = False
    freebayes.params = None
    freebayes.reference_sequence = self.refdata['reference_genome']
    freebayes.target_bed = self.refdata['targets'][targets]['targets-bed-slopped20']
    freebayes.threads = self.maxcores
    freebayes.scratch = self.scratch
    freebayes.output = &quot;{}/variants/{}.freebayes-germline.vcf.gz&quot;.format(self.outdir, capture_str)
    freebayes.jobname = &quot;freebayes-germline-{}&quot;.format(capture_str)
    self.add(freebayes)

    vepped_vcf = None
    if self.vep_data_is_available():
        vep_freebayes = VEP()
        vep_freebayes.input_vcf = freebayes.output
        vep_freebayes.threads = self.maxcores
        vep_freebayes.reference_sequence = self.refdata['reference_genome']
        vep_freebayes.vep_dir = self.refdata['vep_dir']
        vep_freebayes.output_vcf = &quot;{}/variants/{}.freebayes-germline.vep.vcf.gz&quot;.format(self.outdir, capture_str)
        vep_freebayes.jobname = &quot;vep-freebayes-germline-{}&quot;.format(capture_str)
        self.add(vep_freebayes)
        vepped_vcf = vep_freebayes.output_vcf

    self.set_germline_vcf(normal_capture, (freebayes.output, vepped_vcf))
</code></pre>

<h3 id="configure_panel_analysis_with_normal">configure_panel_analysis_with_normal</h3>
<p>Configure panel analyses focused on a specific unique normal library capture.</p>
<ul>
<li>Configure germline variant calling:</li>
<li>For each unique cancer library capture, configure a comparative analysis against this normal capture:</li>
</ul>
<pre><code class="py">def configure_panel_analysis_with_normal(self, normal_capture):

    if normal_capture.sample_type != &quot;N&quot;:
        raise ValueError(&quot;Invalid input capture: &quot; + compose_sample_str(normal_capture))

    normal_bam = self.get_capture_bam(normal_capture)

    self.call_germline_variants(normal_capture, normal_bam)


    for cancer_capture in self.get_mapped_captures_cancer():
        self.configure_panel_analysis_cancer_vs_normal(
            normal_capture, cancer_capture)
</code></pre>

<h3 id="configure_make_cnvkit_tracks">configure_make_cnvkit_tracks</h3>
<pre><code class="py">def configure_make_cnvkit_tracks(self, unique_capture):
    input_cnr = self.capture_to_results[unique_capture].cnr
    input_cns = self.capture_to_results[unique_capture].cns

    sample_str = compose_lib_capture_str(unique_capture)

    make_cnvkit_tracks = MakeCNVkitTracks()
    make_cnvkit_tracks.input_cnr = input_cnr
    make_cnvkit_tracks.input_cns = input_cns
    make_cnvkit_tracks.output_profile_bedgraph = &quot;{}/cnv/{}_profile.bedGraph&quot;.format(
        self.outdir, sample_str)
    make_cnvkit_tracks.output_segments_bedgraph = &quot;{}/cnv/{}_segments.bedGraph&quot;.format(
        self.outdir, sample_str)
    self.add(make_cnvkit_tracks)
</code></pre>

<h3 id="configure_fix_cnvkit">configure_fix_cnvkit</h3>
<p>Configure a job to fix the cnvkit output for the specified unique capture.</p>
<ul>
<li>param unique_capture: Named tuple identifying a sample library capture.</li>
<li>param cnr: String indicating unfixed cnr file location</li>
<li>param cns: String indicating unfixed cns file location</li>
<li>param cnvkit_fix_filename: File containing table of data used to fix the outputs.</li>
</ul>
<pre><code class="py">def configure_fix_cnvkit(self, unique_capture, cnr, cns, cnvkit_fix_filename):

    sample_str = compose_lib_capture_str(unique_capture)

    cnvkit_fix = CNVkitFix(input_cnr=cnr,
                           input_cns=cns,
                           input_ref=cnvkit_fix_filename,
                           output_cnr=&quot;{}/cnv/{}-fixed.cnr&quot;.format(self.outdir, sample_str),
                           output_cns=&quot;{}/cnv/{}-fixed.cns&quot;.format(self.outdir, sample_str))

    self.set_capture_cnr(unique_capture, cnvkit_fix.output_cnr)
    self.set_capture_cns(unique_capture, cnvkit_fix.output_cns)

    self.add(cnvkit_fix)
</code></pre>

<h3 id="configure_single_capture_analysis">configure_single_capture_analysis</h3>
<p>Configure all general analyses to perform given a single sample library capture.</p>
<pre><code class="py">def configure_single_capture_analysis(self, unique_capture):

    input_bam = self.get_capture_bam(unique_capture)
    sample_str = compose_lib_capture_str(unique_capture)
    capture_kit_name = self.get_capture_name(unique_capture.capture_kit_id)
    library_kit_name = self.get_prep_kit_name(unique_capture.library_kit_id)
    sample_type = unique_capture.sample_type

    # Configure CNV kit analysis:
    cnvkit = CNVkit(input_bam=input_bam,
                    output_cnr=&quot;{}/cnv/{}.cnr&quot;.format(self.outdir, sample_str),
                    output_cns=&quot;{}/cnv/{}.cns&quot;.format(self.outdir, sample_str),
                    scratch=self.scratch)

    # FIXME: Improve this messy code for extracting the relevant cnvkit reference from self.refdata:
    cnvkit.reference = None
    if 'cnvkit-ref' in self.refdata['targets'][capture_kit_name]:
        # Retrieve the first (in arbitrary order) reference available for this capture kit,
        # as a fall-back:
        cnvkit.reference = self.refdata['targets'][capture_kit_name]['cnvkit-ref'].values()[0].values()[0]
    try:
        # Try to get a more specific reference, if it available:
        cnvkit.reference = self.refdata['targets'][capture_kit_name]['cnvkit-ref'][library_kit_name][sample_type]
    except KeyError:
        pass

    if not cnvkit.reference:
        cnvkit.targets_bed = self.refdata['targets'][capture_kit_name]['targets-bed-slopped20']
        cnvkit.fasta = self.refdata[&quot;reference_genome&quot;]

    cnvkit.jobname = &quot;cnvkit/{}&quot;.format(sample_str)

    # Register the result of this analysis:
    self.set_capture_cnr(unique_capture, cnvkit.output_cnr)
    self.set_capture_cns(unique_capture, cnvkit.output_cns)

    # FIXME: This extra step (fixing the cnv kit output) should perhaps go elsewhere.
    try:
        # Only fix the CNV-kit output if the required file is available:
        cnvkit_fix_filename = \
            self.refdata['targets'][capture_kit_name][&quot;cnvkit-fix&quot;][library_kit_name][sample_type]
        self.configure_fix_cnvkit(unique_capture, cnvkit.output_cnr, cnvkit.output_cns, cnvkit_fix_filename)
    except KeyError:
        pass

    self.add(cnvkit)

    # Configure conversion of CNV kit output to seg format:
    seg_filename = &quot;{}/cnv/{}.seg&quot;.format(
        self.outdir, sample_str)
    cns2seg = Cns2Seg(self.capture_to_results[unique_capture].cns, seg_filename)
    self.add(cns2seg)

    self.set_capture_seg(unique_capture, cns2seg.output_seg)
</code></pre>

<h3 id="configure_lowpass_analyses">configure_lowpass_analyses</h3>
<p>Configure generic analyses of all low-pass whole-genome sequencing
data for this clinseq pipeline, under the assumption that alignment and
bam file merging has already been performed.</p>
<pre><code class="py">def configure_lowpass_analyses(self):

    for unique_wgs in self.get_mapped_captures_only_wgs():
        self.configure_single_wgs_analyses(unique_wgs)
</code></pre>

<h3 id="configure_make_qdnaseq_tracks">configure_make_qdnaseq_tracks</h3>
<pre><code class="py">def configure_make_qdnaseq_tracks(self, qdnaseq_output, sample_str):
    make_qdnaseq_tracks = MakeQDNAseqTracks()
    make_qdnaseq_tracks.input_qdnaseq_file = qdnaseq_output
    make_qdnaseq_tracks.output_segments_bedgraph = &quot;{}/cnv/{}_qdnaseq_segments.bedGraph&quot;.format(
        self.outdir, sample_str)
    make_qdnaseq_tracks.output_copynumber_tdf = &quot;{}/cnv/{}_qdnaseq_copynumber.tdf&quot;.format(
        self.outdir, sample_str)
    make_qdnaseq_tracks.output_readcount_tdf = &quot;{}/cnv/{}_qdnaseq_readcount.tdf&quot;.format(
        self.outdir, sample_str)
    self.add(make_qdnaseq_tracks)
</code></pre>

<h3 id="configure_single_wgs_analyses">configure_single_wgs_analyses</h3>
<p>Configure generic analyses of a single WGS item in the pipeline.</p>
<ul>
<li>param unique_wgs: An identifier for a single unique library WGS.</li>
</ul>
<pre><code class="py">def configure_single_wgs_analyses(self, unique_wgs):

    input_bam = self.get_capture_bam(unique_wgs)
    sample_str = compose_lib_capture_str(unique_wgs)

    qdnaseq = QDNASeq(input_bam,
                      output_segments=&quot;{}/cnv/{}-qdnaseq.segments.txt&quot;.format(
                          self.outdir, sample_str),
                      background=None)

    self.configure_make_qdnaseq_tracks(qdnaseq.output, sample_str)

    self.add(qdnaseq)
</code></pre>

<h3 id="run_wgs_bam_qc">run_wgs_bam_qc</h3>
<p>Run QC on wgs bams</p>
<ul>
<li>param bams: list of bams</li>
<li>return: list of generated files</li>
</ul>
<pre><code class="py">def run_wgs_bam_qc(self, bams):

    qc_files = []
    logging.debug(&quot;bams are {}&quot;.format(bams))
    for bam in bams:
        basefn = stripsuffix(os.path.basename(bam), &quot;.bam&quot;)
        isize = PicardCollectInsertSizeMetrics()
        isize.input = bam
        isize.jobname = &quot;picard-isize-{}&quot;.format(basefn)
        isize.output_metrics = &quot;{}/qc/picard/wgs/{}.picard-insertsize.txt&quot;.format(self.outdir, basefn)
        self.add(isize)

        wgsmetrics = PicardCollectWgsMetrics()
        wgsmetrics.input = bam
        wgsmetrics.reference_sequence = self.refdata['reference_genome']
        wgsmetrics.output_metrics = &quot;{}/qc/picard/wgs/{}.picard-wgsmetrics.txt&quot;.format(self.outdir, basefn)
        wgsmetrics.jobname = &quot;picard-wgsmetrics-{}&quot;.format(basefn)
        self.add(wgsmetrics)

        qc_files += [isize.output_metrics, wgsmetrics.output_metrics]

    return qc_files
</code></pre>

<h3 id="configure_panel_analyses">configure_panel_analyses</h3>
<p>Configure generic analyses of all panel data for this clinseq pipeline, assuming that alignment and bam file merging has been performed.</p>
<pre><code class="py">def configure_panel_analyses(self):

    # Configure analyses to be run on all unique panel captures individually:
    for unique_capture in self.get_mapped_captures_no_wgs():
        self.configure_single_capture_analysis(unique_capture)
        self.configure_make_cnvkit_tracks(unique_capture)

    # Configure a separate group of analyses for each unique normal library capture:
    for normal_capture in self.get_mapped_captures_normal():
        self.configure_panel_analysis_with_normal(normal_capture)
</code></pre>

<h3 id="configure_panel_msings_analyses">configure_panel_msings_analyses</h3>
<p>Configure msings analyses for all unique captures for which this is possible.</p>
<pre><code class="py">def configure_panel_msings_analyses(self):

    for unique_capture in self.get_mapped_captures_cancer():
        try:
            self.configure_msings(unique_capture)
        except InvalidRefDataException:
            # This indicates the reference data does not support configuring
            # msings for this cancer capture =&gt; Ignore this and proceed to the next:
            pass
</code></pre>

<h3 id="configure_somatic_calling">configure_somatic_calling</h3>
<p>Configure somatic variant calling in this pipeline, for a specified pairing of normal and cancer library capture events. </p>
<ul>
<li>param normal_capture: Named tuple indicating normal library capture.</li>
<li>param cancer_capture: Named tuple indicating cancer library capture.</li>
</ul>
<pre><code class="py">def configure_somatic_calling(self, normal_capture, cancer_capture):

    cancer_bam = self.get_capture_bam(cancer_capture)
    normal_bam = self.get_capture_bam(normal_capture)
    target_name = self.get_capture_name(cancer_capture.capture_kit_id)

    # FIXME: Need to fix the configuration of the min_alt_frac threshold, rather than hard-coding it here:
    somatic_variants = call_somatic_variants(
        self, cancer_bam=cancer_bam, normal_bam=normal_bam,
        cancer_capture=cancer_capture, normal_capture=normal_capture,
        target_name=target_name,
        outdir=self.outdir, callers=['vardict'],
        min_alt_frac=self.get_job_param('vardict-min-alt-frac'),
        min_num_reads=self.get_job_param('vardict-min-num-reads'))

    self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].somatic_vcf = \
        somatic_variants.values()[0]
</code></pre>

<h3 id="configure_vep">configure_vep</h3>
<pre><code class="py">def configure_vep(self, normal_capture, cancer_capture):
    if not self.vep_data_is_available():
        raise ValueError(&quot;Invalid call to configure_vep: No vep data available.&quot;)

    somatic_vcf = self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].somatic_vcf

    cancer_capture_str = compose_lib_capture_str(cancer_capture)
    normal_capture_str = compose_lib_capture_str(normal_capture)

    vep = VEP()
    vep.input_vcf = somatic_vcf
    vep.threads = self.maxcores
    vep.reference_sequence = self.refdata['reference_genome']
    vep.vep_dir = self.refdata['vep_dir']
    vep.output_vcf = &quot;{}/variants/{}-{}.somatic.vep.vcf.gz&quot;.format(
        self.outdir, cancer_capture_str, normal_capture_str)
    vep.jobname = &quot;vep-freebayes-somatic/{}&quot;.format(cancer_capture_str)
    vep.additional_options = self.get_job_param(&quot;vep-additional-options&quot;)
    self.add(vep)
    self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].vepped_vcf = \
        vep.output_vcf
</code></pre>

<h3 id="configure_make_allelic_fraction_track">configure_make_allelic_fraction_track</h3>
<p>Configure a small job for converting the germline variant somatic allelic fraction information into tracks for displaying in IGV.</p>
<ul>
<li>param normal_capture: Named tuple indicating normal library capture.</li>
<li>param cancer_capture: Named tuple indicating cancer library capture.</li>
</ul>
<pre><code class="py">def configure_make_allelic_fraction_track(self, normal_capture, cancer_capture):

    vcf = self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].vcf_addsample_output
    make_allelic_fraction_track = MakeAllelicFractionTrack()
    make_allelic_fraction_track.input_vcf = vcf
    normal_capture_str = compose_lib_capture_str(normal_capture)
    cancer_capture_str = compose_lib_capture_str(cancer_capture)
    make_allelic_fraction_track.output_bedgraph = \
        &quot;{}/variants/{}-and-{}.germline-variants-somatic-afs.bedGraph&quot;.format(
        self.outdir, normal_capture_str, cancer_capture_str)
    self.add(make_allelic_fraction_track)
</code></pre>

<h3 id="configure_vcf_add_sample">configure_vcf_add_sample</h3>
<p>Configure VCF updating in this pipeline, for a specified pairing of normal and cancer library capture events. </p>
<ul>
<li>param normal_capture: Named tuple indicating normal library capture.</li>
<li>param cancer_capture: Named tuple indicating cancer library capture.</li>
</ul>
<pre><code class="py">def configure_vcf_add_sample(self, normal_capture, cancer_capture):
    # Configure VCF add sample:
    vcfaddsample = VcfAddSample()
    vcfaddsample.input_bam = self.get_capture_bam(cancer_capture)
    vcfaddsample.input_vcf = self.get_germline_vcf(normal_capture)
    normal_capture_str = compose_lib_capture_str(normal_capture)
    cancer_capture_str = compose_lib_capture_str(cancer_capture)
    cancer_sample_str = compose_sample_str(cancer_capture)
    vcfaddsample.samplename = cancer_sample_str
    vcfaddsample.filter_hom = True
    vcfaddsample.output = &quot;{}/variants/{}-and-{}.germline-variants-with-somatic-afs.vcf.gz&quot;.format(
        self.outdir, normal_capture_str, cancer_capture_str)
    vcfaddsample.jobname = &quot;vcf-add-sample-{}&quot;.format(cancer_capture_str)
    self.add(vcfaddsample)
    self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].vcf_addsample_output = \
        vcfaddsample.output
</code></pre>

<h3 id="configure_msi_sensor">configure_msi_sensor</h3>
<p>Configure MSI sensor in this pipeline, for a specified pairing of normal and cancer library capture events. </p>
<ul>
<li>param normal_capture: Named tuple indicating normal library capture.</li>
<li>param cancer_capture: Named tuple indicating cancer library capture.</li>
</ul>
<pre><code class="py">def configure_msi_sensor(self, normal_capture, cancer_capture):

    # Configure MSI sensor:
    msisensor = MsiSensor()
    cancer_capture_name = self.get_capture_name(cancer_capture.capture_kit_id)
    msisensor.msi_sites = self.refdata['targets'][cancer_capture_name]['msisites']
    msisensor.input_normal_bam = self.get_capture_bam(normal_capture)
    msisensor.input_tumor_bam = self.get_capture_bam(cancer_capture)
    normal_capture_str = compose_lib_capture_str(normal_capture)
    cancer_capture_str = compose_lib_capture_str(cancer_capture)
    msisensor.output = &quot;{}/msisensor-{}-{}.tsv&quot;.format(
        self.outdir, normal_capture_str, cancer_capture_str)
    msisensor.threads = self.maxcores
    msisensor.jobname = &quot;msisensor-{}-{}&quot;.format(normal_capture_str, cancer_capture_str)
    self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].msi_output = \
        msisensor.output
    self.add(msisensor)
</code></pre>

<h3 id="configure_msings">configure_msings</h3>
<p>Configure msings analysis, which operates on a cancer capture bam input file.</p>
<ul>
<li>param cancer_capture: Named tuple indicating cancer library capture.</li>
</ul>
<pre><code class="py">def configure_msings(self, cancer_capture):

    # Configure Msings:
    msings = Msings()
    cancer_capture_name = self.get_capture_name(cancer_capture.capture_kit_id)
    msings.input_fasta = self.refdata['reference_genome']
    try:
        msings.msings_baseline = self.refdata['targets'][cancer_capture_name]['msings-baseline']
        msings.msings_bed = self.refdata['targets'][cancer_capture_name]['msings-bed']
        msings.msings_intervals = self.refdata['targets'][cancer_capture_name]['msings-msi_intervals']
    except KeyError:
        raise InvalidRefDataException(&quot;Missing msings data.&quot;)

    # FIXME: The above logic could be cleaned up.
    if not msings.msings_bed:
        raise InvalidRefDataException(&quot;Missing msings data.&quot;)

    msings.input_bam = self.get_capture_bam(cancer_capture)
    cancer_capture_str = compose_lib_capture_str(cancer_capture)
    msings.outdir = &quot;{}/msings-{}&quot;.format(
        self.outdir, cancer_capture_str)
    # FIXME: This is nasty:
    bam_name = os.path.splitext(os.path.basename(msings.input_bam))[0]
    msings.output = &quot;{}/{}/{}.MSI_Analysis.txt&quot;.format(
        msings.outdir, bam_name, bam_name)
    msings.threads = self.maxcores
    msings.jobname = &quot;msings-{}&quot;.format(cancer_capture_str)
    self.capture_to_results[cancer_capture].msings_output = msings.output
    self.add(msings)
</code></pre>

<h3 id="configure_hz_conc">configure_hz_conc</h3>
<p>Configure heterozygote concordance calculation in this pipeline, for a
specified pairing of normal and cancer library capture events. </p>
<ul>
<li>param normal_capture: Named tuple indicating normal library capture.</li>
<li>param cancer_capture: Named tuple indicating cancer library capture.</li>
</ul>
<pre><code class="py">def configure_hz_conc(self, normal_capture, cancer_capture):

    # Configure heterozygote concordance:
    hzconcordance = HeterzygoteConcordance()
    hzconcordance.input_vcf = self.get_germline_vcf(normal_capture)
    hzconcordance.input_bam = self.get_capture_bam(cancer_capture)
    hzconcordance.reference_sequence = self.refdata['reference_genome']
    cancer_capture_name = self.get_capture_name(cancer_capture.capture_kit_id)
    hzconcordance.target_regions = \
        self.refdata['targets'][cancer_capture_name]['targets-interval_list-slopped20']
    hzconcordance.normalid = compose_sample_str(normal_capture)
    hzconcordance.filter_reads_with_N_cigar = True
    hzconcordance.jobname = &quot;hzconcordance-{}&quot;.format(compose_lib_capture_str(cancer_capture))
    hzconcordance.output = &quot;{}/bams/{}-{}-hzconcordance.txt&quot;.format(
        self.outdir, compose_lib_capture_str(cancer_capture), compose_lib_capture_str(normal_capture))
    self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].hzconcordance_output = \
        hzconcordance.output
    self.add(hzconcordance)
</code></pre>

<h3 id="configure_contest_vcf_generation">configure_contest_vcf_generation</h3>
<p>Configure generation of a contest VCF input file in this pipeline, for a specified pairing of normal and cancer library capture events. </p>
<ul>
<li>param normal_capture: Named tuple indicating normal library capture.</li>
<li>param cancer_capture: Named tuple indicating cancer library capture.</li>
</ul>
<pre><code class="py">def configure_contest_vcf_generation(self, normal_capture, cancer_capture):

    contest_vcf_generation = CreateContestVCFs()
    normal_capture_name = self.get_capture_name(normal_capture.capture_kit_id)
    cancer_capture_name = self.get_capture_name(cancer_capture.capture_kit_id)
    normal_targets = self.refdata['targets'][normal_capture_name]['targets-bed-slopped20']
    cancer_targets = self.refdata['targets'][cancer_capture_name]['targets-bed-slopped20']
    contest_vcf_generation.input_target_regions_bed_1 = normal_targets
    contest_vcf_generation.input_target_regions_bed_2 = cancer_targets
    contest_vcf_generation.input_population_vcf = self.refdata[&quot;swegene_common&quot;]
    normal_capture_str = compose_lib_capture_str(normal_capture)
    cancer_capture_str = compose_lib_capture_str(cancer_capture)
    contest_vcf_generation.output = &quot;{}/contamination/pop_vcf_{}-{}.vcf&quot;.format(
        self.outdir, normal_capture_str, cancer_capture_str)
    contest_vcf_generation.jobname = &quot;contest_pop_vcf_{}-{}&quot;.format(
        normal_capture_str, cancer_capture_str)
    self.add(contest_vcf_generation)
    return contest_vcf_generation.output
</code></pre>

<h3 id="configure_contest">configure_contest</h3>
<p>Configure running of ContEst in this pipeline, for a specified pairing
of library capture events. Estimates contamination in the bam file for the
first library capture, using the bam file for the second library capture as
a reference comparison.</p>
<ul>
<li>param library_capture_1: Named tuple indicating first library capture.</li>
<li>param library_capture_2: Named tuple indicating second library capture.</li>
<li>param contest_vcf: Contest population allele frequency VCF input file.</li>
</ul>
<pre><code class="py">def configure_contest(self, library_capture_1, library_capture_2, contest_vcf):

    contest = ContEst()
    contest.reference_genome = self.refdata['reference_genome']
    contest.input_eval_bam = self.get_capture_bam(library_capture_1)
    contest.input_genotype_bam = self.get_capture_bam(library_capture_2)
    contest.input_population_af_vcf = contest_vcf
    # TODO: Is it necessary to create the output subdir contamination somewhere? Check how it's done for e.g. cnvkit.
    contest.output = &quot;{}/contamination/{}.contest.txt&quot;.format(self.outdir, compose_lib_capture_str(library_capture_1)) # TODO: Should the analysis id also be in name of out file?
    contest.jobname = &quot;contest_tumor/{}&quot;.format(compose_lib_capture_str(library_capture_1))  # TODO: Is it ok that the job name does not contain analysis id, i.e. may not be unique?
    self.add(contest)
    return contest.output
</code></pre>

<h3 id="configure_contam_qc_call">configure_contam_qc_call</h3>
<p>Configure generation of a contamination QC call in this pipeline, based on the specified contest output. Returns the resulting QC output filename.</p>
<ul>
<li>param contest_output: ContEst output filename.</li>
<li>param library_capture: Named tuple identifying a unique library capture.</li>
</ul>
<pre><code class="py">def configure_contam_qc_call(self, contest_output, library_capture):

    process_contest = ContEstToContamCaveat()
    process_contest.input_contest_results = contest_output
    process_contest.output = &quot;{}/qc/{}-contam-qc-call.json&quot;.format(
        self.outdir, compose_lib_capture_str(library_capture))
    self.add(process_contest)
    return process_contest.output
</code></pre>

<h3 id="configure_contamination_estimate">configure_contamination_estimate</h3>
<p>Configure contamination estimatates for a given normal, cancer library capture
pairing.</p>
<ul>
<li>param normal_capture: Namedtuple indicating a normal library capture.</li>
<li>param cancer_capture: Namedtuple indicating a cancer library capture. </li>
</ul>
<pre><code class="py">def configure_contamination_estimate(self, normal_capture, cancer_capture):
    # Configure generation of the contest VCF input file:
    intersection_contest_vcf = \
        self.configure_contest_vcf_generation(normal_capture, cancer_capture)

    # Configure contest for calculating contamination in the cancer sample:
    cancer_vs_normal_contest_output = \
        self.configure_contest(cancer_capture, normal_capture, intersection_contest_vcf)

    # Configure contest for calculating contamination in the normal sample:
    normal_vs_cancer_contest_output = \
        self.configure_contest(normal_capture, cancer_capture, intersection_contest_vcf)

    # Configure cancer sample contamination QC call:
    cancer_contam_call = self.configure_contam_qc_call(cancer_vs_normal_contest_output,
                                                       cancer_capture)

    # Register the outputs of running contest:
    self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].normal_contest_output = \
        normal_vs_cancer_contest_output
    self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].cancer_contest_output = \
        cancer_vs_normal_contest_output
    self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].cancer_contam_call = \
        cancer_contam_call
</code></pre>

<h3 id="configure_purecn">configure_purecn</h3>
<p>Configure PureCN, and also configure the custom run of VarDict, which is required for PureCN.</p>
<p>:param normal_capture: A unique normal sample library capture
:param cancer_capture: A unique cancer sample library capture</p>
<pre><code class="py">def configure_purecn(self, normal_capture, cancer_capture):

    cancer_bam = self.get_capture_bam(cancer_capture)
    normal_bam = self.get_capture_bam(normal_capture)
    target_name = self.get_capture_name(cancer_capture.capture_kit_id)

    cancer_capture_str = compose_lib_capture_str(cancer_capture)
    capture_name = self.get_capture_name(cancer_capture.capture_kit_id)
    normal_capture_str = compose_lib_capture_str(normal_capture)

    # Configure the PureCN-specific VarDict job:
    vardict_pureCN = VarDictForPureCN()
    vardict_pureCN.input_tumor = cancer_bam
    vardict_pureCN.input_normal = normal_bam
    vardict_pureCN.tumorid = cancer_capture_str
    vardict_pureCN.normalid = normal_capture_str
    vardict_pureCN.reference_sequence = self.refdata['reference_genome']
    vardict_pureCN.reference_dict = self.refdata['reference_dict']
    vardict_pureCN.target_bed = self.refdata['targets'][target_name]['targets-bed-slopped20']
    vardict_pureCN.dbsnp = self.refdata[&quot;dbSNP&quot;]
    vardict_pureCN.output = &quot;{}/variants/{}-{}.vardict-somatic-purecn.vcf.gz&quot;.format(
        self.outdir, cancer_capture_str, normal_capture_str)
    vardict_pureCN.jobname = &quot;vardict_purecn/{}-{}&quot;.format(cancer_capture_str, normal_capture_str)
    self.add(vardict_pureCN)

    # Retrieve the relevant seg-format file:
    seg_filename = self.capture_to_results[cancer_capture].seg

    # Configure PureCN itself:
    # FIXME: NOTE: The Job params *must* be specified as arguments in the case of PureCN:
    pureCN = PureCN(
        input_seg=seg_filename,
        input_vcf=vardict_pureCN.output,
        tumorid=cancer_capture_str,
        gcgene_file=self.refdata['targets'][capture_name]['purecn_targets'],
        outdir=&quot;{}/purecn&quot;.format(self.outdir),
        postopt=True,
    )
    self.add(pureCN)

    # FIXME: It seems like a nasty hack to include a dictionary here, perhaps this belongs elsewhere?
    self.normal_cancer_pair_to_results[(normal_capture, cancer_capture)].pureCN_outputs = {
        &quot;csv&quot;: &quot;{}/{}.csv&quot;.format(pureCN.outdir, pureCN.tumorid),
        &quot;genes_csv&quot;: &quot;{}/{}_genes.csv&quot;.format(pureCN.outdir, pureCN.tumorid),
        &quot;loh_csv&quot;: &quot;{}/{}_loh.csv&quot;.format(pureCN.outdir, pureCN.tumorid),
        &quot;variants_csv&quot;: &quot;{}/{}_variants.csv&quot;.format(pureCN.outdir, pureCN.tumorid),
    }

</code></pre>

<h3 id="configure_panel_analysis_cancer_vs_normal">configure_panel_analysis_cancer_vs_normal</h3>
<p>Configures standard paired cancer vs normal panel analyses for the specified unique normal and cancer library captures.</p>
<p>Comprises the following analyses:
    - Somatic variant calling
    - Running VEP on the resulting somatic VCF
    - Updating of the germline VCF to take into consideration the cancer sample
    - MSI sensor
    - Heterozygote concordance of the sample pair
    - Contamination estimate of cancer compared with normal and vice versa</p>
<ul>
<li>param normal_capture: A unique normal sample library capture</li>
<li>param cancer_capture: A unique cancer sample library capture</li>
</ul>
<pre><code class="py">def configure_panel_analysis_cancer_vs_normal(self, normal_capture, cancer_capture):

    self.configure_somatic_calling(normal_capture, cancer_capture)
    if self.vep_data_is_available():
        self.configure_vep(normal_capture, cancer_capture)
    self.configure_vcf_add_sample(normal_capture, cancer_capture)
    self.configure_make_allelic_fraction_track(normal_capture, cancer_capture)
    self.configure_msi_sensor(normal_capture, cancer_capture)
    self.configure_hz_conc(normal_capture, cancer_capture)
    self.configure_contamination_estimate(normal_capture, cancer_capture)


</code></pre>

<h3 id="configure_all_lowpass_qcs">configure_all_lowpass_qcs</h3>
<p>Configure QC checks for all low-pass whole genome data in this pipeline.</p>
<pre><code class="py">def configure_all_lowpass_qcs(self):

    for unique_wgs in self.get_mapped_captures_only_wgs():
        self.qc_files += \
            self.configure_wgs_qc(unique_wgs)
</code></pre>

<h3 id="configure_wgs_qc">configure_wgs_qc</h3>
<p>Configure QC checks for the specified unique WGS item in this pipeline.</p>
<ul>
<li>param unique_wgs: A named tuple identifying a single unique WGS item.</li>
<li>return: QC files output files resulting from the QC analysis configuration.</li>
</ul>
<pre><code class="py">def configure_wgs_qc(self, unique_wgs):

    bam = self.get_capture_bam(unique_wgs)
    wgs_name = compose_lib_capture_str(unique_wgs)

    qc_files = []

    isize = PicardCollectInsertSizeMetrics()
    isize.input = bam
    isize.jobname = &quot;picard-isize-{}&quot;.format(wgs_name)
    isize.output_metrics = &quot;{}/qc/picard/wgs/{}.picard-insertsize.txt&quot;.format(self.outdir, wgs_name)
    self.add(isize)

    wgsmetrics = PicardCollectWgsMetrics()
    wgsmetrics.input = bam
    wgsmetrics.reference_sequence = self.refdata['reference_genome']
    wgsmetrics.output_metrics = &quot;{}/qc/picard/wgs/{}.picard-wgsmetrics.txt&quot;.format(self.outdir, wgs_name)
    wgsmetrics.jobname = &quot;picard-wgsmetrics-{}&quot;.format(wgs_name)
    self.add(wgsmetrics)

    qc_files += [isize.output_metrics, wgsmetrics.output_metrics]

    return qc_files
</code></pre>

<h3 id="configure_all_panel_qcs">configure_all_panel_qcs</h3>
<p>Configures QC checks for all panel data (not including WGS data) in this pipeline.</p>
<pre><code class="py">def configure_all_panel_qcs(self):

    for unique_capture in self.get_mapped_captures_no_wgs():
        self.qc_files += \
            self.configure_panel_qc(unique_capture)
</code></pre>

<h3 id="configure_multi_qc">configure_multi_qc</h3>
<p>Configures MultiQC for this pipeline. self.qc_files must be fully populated in order for MultiQC to use all relevant input files.</p>
<pre><code class="py">def configure_multi_qc(self):
    multiqc = MultiQC()
    multiqc.input_files = self.qc_files
    multiqc.search_dir = self.outdir
    multiqc.output = &quot;{}/multiqc/{}-multiqc&quot;.format(self.outdir, self.analysis_id)
    multiqc.jobname = &quot;multiqc-{}&quot;.format(self.sampledata['sdid'])
    self.add(multiqc)
</code></pre>

<h3 id="get_coverage_bed">get_coverage_bed</h3>
<p>Retrieve the targets bed file to use for calculating coverage, given the specified targets name.</p>
<ul>
<li>param targets: Target capture name</li>
<li>return: bed file name</li>
</ul>
<pre><code class="py">def get_coverage_bed(self, targets):

    return self.refdata['targets'][targets]['targets-bed-slopped20']
</code></pre>

<h3 id="configure_panel_qc">configure_panel_qc</h3>
<p>Configure QC analyses for a given library capture.</p>
<ul>
<li>param unique_capture: Named tuple identifying a sample library capture.</li>
<li>return: list of QC output files for this capture.</li>
</ul>
<pre><code class="py">def configure_panel_qc(self, unique_capture):

    bam = self.get_capture_bam(unique_capture)

    targets = self.get_capture_name(unique_capture.capture_kit_id)
    logging.debug(&quot;Adding QC jobs for {}&quot;.format(bam))

    capture_str = compose_lib_capture_str(unique_capture)

    isize = PicardCollectInsertSizeMetrics()
    isize.input = bam
    isize.output_metrics = &quot;{}/qc/picard/{}/{}.picard-insertsize.txt&quot;.format(
        self.outdir, unique_capture.capture_kit_id, capture_str)
    isize.jobname = &quot;picard-isize-{}&quot;.format(capture_str)
    self.add(isize)

    oxog = PicardCollectOxoGMetrics()
    oxog.input = bam
    oxog.reference_sequence = self.refdata['reference_genome']
    oxog.output_metrics = &quot;{}/qc/picard/{}/{}.picard-oxog.txt&quot;.format(
        self.outdir, unique_capture.capture_kit_id, capture_str)
    oxog.jobname = &quot;picard-oxog-{}&quot;.format(capture_str)
    self.add(oxog)

    hsmetrics = PicardCollectHsMetrics()
    hsmetrics.input = bam
    hsmetrics.reference_sequence = self.refdata['reference_genome']
    hsmetrics.target_regions = self.refdata['targets'][targets][
        'targets-interval_list-slopped20']
    hsmetrics.bait_regions = self.refdata['targets'][targets][
        'targets-interval_list-slopped20']
    hsmetrics.bait_name = targets
    hsmetrics.output_metrics = &quot;{}/qc/picard/{}/{}.picard-hsmetrics.txt&quot;.format(
        self.outdir, unique_capture.capture_kit_id, capture_str)
    hsmetrics.jobname = &quot;picard-hsmetrics-{}&quot;.format(capture_str)
    self.add(hsmetrics)

    sambamba = SambambaDepth()
    sambamba.targets_bed = self.refdata['targets'][targets]['targets-bed-slopped20']
    sambamba.input = bam
    sambamba.output = &quot;{}/qc/sambamba/{}.sambamba-depth-targets.txt&quot;.format(
        self.outdir, capture_str)
    sambamba.jobname = &quot;sambamba-depth-{}&quot;.format(capture_str)
    self.add(sambamba)

    coverage_hist = CoverageHistogram()
    # FIXME: Ugly temporary solution to allow the alascca pipeline to use a specific
    # targets file:
    coverage_hist.input_bed = self.get_coverage_bed(targets)
    coverage_hist.input_bam = bam
    coverage_hist.output = &quot;{}/qc/{}.coverage-histogram.txt&quot;.format(
        self.outdir, capture_str)
    coverage_hist.jobname = &quot;alascca-coverage-hist/{}&quot;.format(capture_str)
    self.add(coverage_hist)

    coverage_qc_call = CoverageCaveat()
    coverage_qc_call.low_thresh_fraction = self.get_job_param('cov-low-thresh-fraction')
    coverage_qc_call.low_thresh_fold_cov = self.get_job_param('cov-low-thresh-fold-cov')
    coverage_qc_call.input_histogram = coverage_hist.output
    coverage_qc_call.output = &quot;{}/qc/{}.coverage-qc-call.json&quot;.format(self.outdir, capture_str)
    coverage_qc_call.jobname = &quot;coverage-qc-call/{}&quot;.format(capture_str)
    self.add(coverage_qc_call)
    self.capture_to_results[unique_capture].cov_qc_call = coverage_qc_call.output

    return [isize.output_metrics, oxog.output_metrics, hsmetrics.output_metrics,
            sambamba.output, coverage_hist.output, coverage_qc_call.output]
</code></pre>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/ClinSeq/autoseq" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
